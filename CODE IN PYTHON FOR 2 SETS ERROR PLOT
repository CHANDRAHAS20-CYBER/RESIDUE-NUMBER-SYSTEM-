//CODE FOR FINDING SUM OF 2 NUMBERS RANDOMLY GENERATED BY COMPILER AND FINDING ERROR PERCENTAGE COMPARED WITH ACTUAL SUM AND PLOTTING THE ERROR GRAPH FOR A 2 SET OF INPUTS


from random import randint
import numpy as np
import seaborn as sns
import matplotlib.pyplot as plt

def g_m(n):
    power = 2 ** n
    return [power - 1, power, power + 1]

def condition(n1, n2, m):
    m1 = m[0] * m[1] * m[2]
    return n1 < m1 and n2 < m1 and max(n1, n2) < m1 and (m1 - n1) > n2

def calculate_obtained_sum(n1, n2):
    n = 2
    m = g_m(n)
    while not condition(n1, n2, m):
        n += 1
        m = g_m(n)
    
    p = 1
    for i in m:
        p *= i
    
    a = []
    b = []
    if n1 % 2 == 0 and n2 % 2 == 0:
        pass
    elif n1 % 2 != 0 and n2 % 2 != 0:
        pass
    else:
        n1 = n1 - 1
    for i in m:
        c = n1 % i
        a.append(c)
    for i in m:
        d = n2 % i
        b.append(d)
    A1 = (a[0] + b[0]) % m[0]
    A2 = (a[1] + b[1]) % m[1]
    A3 = (a[2] + b[2]) % m[2]
    M1 = m[1] * m[2]
    M2 = m[0] * m[2]
    M3 = m[0] * m[1]
    m_1 = [2 ** (n - 1), 2 ** (n - 1) - 1, 2 ** (n - 1) + 1]
    
    obtained_sum = (A1 * M1 * m_1[0] + A2 * M2 * m_1[1] + A3 * M3 * m_1[2]) % p
    actual_sum = n1 + n2  # Removed adjustment from here
    error_percentage = abs(obtained_sum - actual_sum) / actual_sum * 100 if actual_sum != 0 else 0  # Handle division by zero

    return error_percentage, obtained_sum

error_percentages = []
obtained_sums = []

# Execute for two sets of n1 and n2
for i in range(2):
    n1 = randint(1, 10000)
    n2 = randint(1, 10000)
    print(f"\nSet {i+1}: n1 = {n1}, n2 = {n2}")

    error_percentage, obtained_sum = calculate_obtained_sum(n1, n2)

    actual_sum = n1 + n2
    difference = min(abs(obtained_sum - actual_sum), abs(actual_sum - obtained_sum))  # Consider both differences
    error_percentage = (difference / actual_sum) * 100 if actual_sum != 0 else 0

    print(f"Actual Sum: {actual_sum}")
    print(f"Obtained Sum: {obtained_sum}")
    print(f"Error Percentage: {error_percentage:.6f}%")
    error_percentages.append(error_percentage)
    obtained_sums.append(obtained_sum)

# Simulating error distributions with small variations
error_percentage_1 = np.random.normal(error_percentages[0], 5, 1000)  
error_percentage_2 = np.random.normal(error_percentages[1], 5, 1000)  

# Create density plots
sns.kdeplot(error_percentage_1, shade=True, color='blue', label=f'Set 1 (Peak at {obtained_sums[0]})')
sns.kdeplot(error_percentage_2, shade=True, color='red', label=f'Set 2 (Peak at {obtained_sums[1]})')

# Customize the plot
plt.xlabel("Error Percentage")
plt.ylabel("Density (Obtained Sum Distribution)")
plt.title("Error Percentage in Obtained Sum")
plt.grid(True)
plt.legend()

# Annotate error percentages on the graph for two sets with a gap
plt.annotate(f"{error_percentages[0]:.4f}%",
             (error_percentages[0], 0.04),
             textcoords="offset points", xytext=(5, 5),
             ha='left', fontsize=10, color='black')

plt.annotate(f"{error_percentages[1]:.4f}%",
             (error_percentages[1], 0.06),
             textcoords="offset points", xytext=(5, 5),
             ha='left', fontsize=10, color='black')

# Display the plot
plt.show()
